# フェーズ1開発タスク計画書

このドキュメントは、GraphVerseのフェーズ1（コア機能）を構築するための、ステップバイステップのタスク計画を定義します。各タスクは、開発担当LLMが一つずつ実行することを想定して、小さく、テスト可能な単位に分割されています。

---

## Week 1: 基盤構築

### タスク 1.1: 既存コードの型エラー修正

-   **目的**: 新しい型定義に合わせて既存のコードを修正し、ビルドエラーを解消する。
-   **やること**:
    1.  `src/store/graphStore.ts` の未使用変数 `additionalText` を修正する。
    2.  `src/components/graph/GraphView.tsx` と `src/components/branch/BranchView.tsx` を新しい型定義に合わせて更新する。
    3.  `bun run lint` でESLintエラーがないことを確認する。
-   **テスト方法**:
    1.  `bun build` がエラーなく完了することを確認する。
    2.  `bun dev` でアプリが正常に起動することを確認する。

### タスク 1.2: 基本レイアウトの実装

-   **目的**: ヘッダーとメイン領域を含む基本的なレイアウト構造を作成する。
-   **やること**:
    1.  `src/components/layout/Header.tsx` を作成し、セッション名表示とナビゲーションを実装する。
    2.  `src/app/page.tsx` を更新し、Header + 左右分割レイアウト（GraphView 60% + BranchView 40%）を実装する。
    3.  レスポンシブ対応（タブレット・モバイル用のクラス追加）を行う。
-   **テスト方法**:
    1.  ブラウザでヘッダーとレイアウトが正しく表示されることを確認する。
    2.  画面サイズを変更して、レスポンシブ動作を確認する。

### タスク 1.3: GraphViewの基本実装

-   **目的**: React Flowを使用した基本的なグラフ表示機能を実装する。
-   **やること**:
    1.  `src/components/graph/GraphView.tsx` を更新し、React Flow統合を実装する。
    2.  Zustandストアから `currentSession.nodes` と `currentSession.edges` を取得し、React Flowに渡す。
    3.  `onNodesChange` と `onEdgesChange` をストアのアクションに接続する。
    4.  基本的なズーム・パン操作を有効にする。
-   **テスト方法**:
    1.  ブラウザでサンプルノードとエッジが表示されることを確認する。
    2.  ノードのドラッグ、背景のパン・ズーム操作ができることを確認する。

### タスク 1.4: ChatCardコンポーネントの実装

-   **目的**: グラフ上のノードをカスタマイズしたChatCardとして表示する。
-   **やること**:
    1.  `src/components/graph/ChatCard.tsx` を作成する。
    2.  React FlowのNodePropsを受け取り、Shadcn/uiのCardを使用してノードデータを表示する。
    3.  author（user/llm）による視覚的な区別を実装する。
    4.  timestamp、tokenCount、選択状態の表示を実装する。
    5.  GraphViewでChatCardをカスタムノードタイプとして登録する。
-   **テスト方法**:
    1.  ノードがCard形式で表示され、ラベル・作成者・その他情報が確認できることを確認する。

## Week 2: 単一ブランチ機能

### タスク 2.1: BranchViewの基本実装

-   **目的**: 選択されたコンテキストとチャット履歴を表示する基本UIを実装する。
-   **やること**:
    1.  `src/components/branch/BranchView.tsx` を更新し、3つのセクションに分割する。
        - ContextManager（選択中のコンテキスト表示）
        - ChatHistory（時系列でのチャット履歴表示）
        - ChatInput（新しいメッセージ入力）
    2.  `src/components/context/ContextManager.tsx` を作成し、選択中のノード一覧とトークン数を表示する。
    3.  `src/components/branch/ChatHistory.tsx` を作成し、現在のブランチのチャット履歴を時系列で表示する。
-   **テスト方法**:
    1.  BranchViewが3つのセクションに分かれて表示されることを確認する。

### タスク 2.2: ノード選択機能の実装

-   **目的**: GraphViewでノードをクリックしてコンテキストとして選択する機能を実装する。
-   **やること**:
    1.  ChatCardにクリックイベントハンドラーを追加する。
    2.  クリック時にZustandストアの `selectContext` アクションを呼び出す。
    3.  選択状態に応じてChatCardの見た目を変更する（枠線の色など）。
    4.  ContextManagerで選択されたノードの詳細を表示する。
-   **テスト方法**:
    1.  ノードをクリックすると、視覚的に選択状態になることを確認する。
    2.  BranchViewのContextManagerに選択されたノードが表示されることを確認する。

### タスク 2.3: ChatInputコンポーネントの実装

-   **目的**: 新しいメッセージを入力・送信するUIを実装する。
-   **やること**:
    1.  `src/components/branch/ChatInput.tsx` を作成する。
    2.  Shadcn/uiのTextareaとButtonを使用してフォームを作成する。
    3.  useStateで入力テキストを管理する。
    4.  送信ボタンクリック時のハンドラーを実装（まずはコンソール出力のみ）。
    5.  トークン制限の表示機能を実装する。
-   **テスト方法**:
    1.  テキストエリアに入力でき、送信ボタンで内容がコンソールに出力されることを確認する。

### タスク 2.4: Chat API の基本実装

-   **目的**: チャット送信を処理するAPIエンドポイントを実装する。
-   **やること**:
    1.  `src/app/api/chat/route.ts` を作成する。
    2.  POSTリクエストを受け取り、リクエストボディ（prompt, contextNodeIds, sessionId, branchType）を解析する。
    3.  Google Generative AIの基本的な呼び出しを実装する（環境変数 `GOOGLE_API_KEY` を使用）。
    4.  Vercel AI SDKを使用したストリーミング応答を実装する。
    5.  エラーハンドリングを追加する。
-   **テスト方法**:
    1.  curlでAPIを呼び出し、Geminiからのストリーミング応答が返ることを確認する。

## Week 3: コンテキスト管理機能

### タスク 3.1: 複数コンテキスト選択機能

-   **目的**: 複数のノードを同時にコンテキストとして選択する機能を実装する。
-   **やること**:
    1.  ChatCardのクリックハンドラーを更新し、Ctrlキー+クリックで複数選択を可能にする。
    2.  ContextManagerで複数のノードを一覧表示し、個別削除ボタンを追加する。
    3.  選択順序の管理を実装する。
    4.  「すべてクリア」ボタンを追加する。
-   **テスト方法**:
    1.  複数のノードを選択し、ContextManagerに正しく表示されることを確認する。
    2.  個別削除とすべてクリアが正常に動作することを確認する。

### タスク 3.2: トークン制限管理機能

-   **目的**: コンテキストの合計トークン数を管理し、制限を超えた場合に警告する機能を実装する。
-   **やること**:
    1.  `src/lib/tokenCounter.ts` を作成し、テキストからトークン数を概算する関数を実装する。
    2.  ContextManagerでリアルタイムにトークン数を計算・表示する。
    3.  制限を超えた場合の警告表示を実装する。
    4.  制限超過時に送信ボタンを無効化する。
    5.  トークン数に応じた視覚的フィードバック（プログレスバーなど）を追加する。
-   **テスト方法**:
    1.  ノードを追加するごとにトークン数が更新されることを確認する。
    2.  制限超過時に適切な警告が表示されることを確認する。

### タスク 3.3: API でのコンテキスト処理

-   **目的**: 選択されたコンテキストをAPIで適切に処理し、LLMに渡す機能を実装する。
-   **やること**:
    1.  Chat APIでcontextNodeIdsを元に該当ノードの内容を取得する。
    2.  コンテキストとして選択されたノードの内容をLLMプロンプトに組み込む。
    3.  branchType（single/merge/new_topic）に応じた処理分岐を実装する。
    4.  新しく生成されるノードのbranchInfoを正しく設定する。
-   **テスト方法**:
    1.  コンテキストを選択してチャットを送信し、過去の内容を踏まえた応答が得られることを確認する。

### タスク 3.4: フロントエンドでのAPI連携

-   **目的**: ChatInputからAPIを呼び出し、応答を受けてグラフを更新する機能を実装する。
-   **やること**:
    1.  ChatInputでVercel AI SDKの `useChat` フックを使用する。
    2.  送信時にselectedNodeIds、sessionId、branchTypeを含むリクエストを送信する。
    3.  ストリーミング応答をリアルタイムでChatHistoryに表示する。
    4.  応答完了時に新しいノードとエッジをZustandストアに追加する。
    5.  エラー時の適切な表示を実装する。
-   **テスト方法**:
    1.  チャット送信から応答表示、グラフ更新まで一連の流れが正常に動作することを確認する。

## Week 4: セッション管理

### タスク 4.1: セッション一覧UI の実装

-   **目的**: 複数のセッションを管理するUIを実装する。
-   **やること**:
    1.  `src/components/session/SessionList.tsx` を作成する。
    2.  Headerにセッション一覧ドロップダウンを追加する。
    3.  セッション作成、切り替え、名前変更の機能を実装する。
    4.  現在のセッション名をヘッダーに表示する。
-   **テスト方法**:
    1.  セッション一覧が表示され、切り替えができることを確認する。

### タスク 4.2: LocalStorage でのデータ永続化

-   **目的**: セッションデータをブラウザのLocalStorageに保存・読み込みする機能を実装する。
-   **やること**:
    1.  `src/lib/storage.ts` を作成し、LocalStorage操作の関数を実装する。
    2.  Zustandストアにpersist機能を追加する。
    3.  セッション切り替え時の自動保存機能を実装する。
    4.  アプリ起動時の自動読み込み機能を実装する。
-   **テスト方法**:
    1.  ブラウザをリロードしてもデータが保持されることを確認する。

### タスク 4.3: Session API の実装

-   **目的**: セッション管理用のAPIエンドポイントを実装する。
-   **やること**:
    1.  `src/app/api/sessions/route.ts` を作成し、GET（一覧取得）とPOST（新規作成）を実装する。
    2.  `src/app/api/sessions/[id]/route.ts` を作成し、個別セッションの取得・更新・削除を実装する。
    3.  当面はLocalStorageベースの実装とし、将来のデータベース連携に備えた構造とする。
-   **テスト方法**:
    1.  APIエンドポイントが正常に動作することをcurlで確認する。

## Week 5: テスト・デバッグ・改善

### タスク 5.1: エラーハンドリングの強化

-   **目的**: 各種エラー状況での適切な表示とユーザーフィードバックを実装する。
-   **やること**:
    1.  API呼び出し失敗時のエラー表示を実装する。
    2.  ネットワークエラー時の再試行機能を追加する。
    3.  LLM応答のタイムアウト処理を実装する。
    4.  ユーザーに分かりやすいエラーメッセージを設計する。
-   **テスト方法**:
    1.  ネットワークを無効にして適切なエラー表示がされることを確認する。

### タスク 5.2: パフォーマンス最適化

-   **目的**: アプリケーションの応答性とパフォーマンスを向上させる。
-   **やること**:
    1.  React Flowの最適化設定を追加する。
    2.  大きなグラフでの描画パフォーマンスを改善する。
    3.  不要な再レンダリングを防ぐためのReact.memoを追加する。
    4.  ローディング状態の表示を改善する。
-   **テスト方法**:
    1.  50個以上のノードでもスムーズな操作ができることを確認する。

### タスク 5.3: ユーザビリティ改善

-   **目的**: より使いやすいUIとUXを実現する。
-   **やること**:
    1.  ローディングスピナーとスケルトンUIを追加する。
    2.  操作時のトランジション・アニメーションを追加する。
    3.  キーボードショートカット（送信: Ctrl+Enter など）を実装する。
    4.  ツールチップやヘルプメッセージを追加する。
-   **テスト方法**:
    1.  ユーザビリティテストを実施し、直感的な操作ができることを確認する。

### タスク 5.4: 総合テストとバグ修正

-   **目的**: フェーズ1の全機能を総合的にテストし、発見されたバグを修正する。
-   **やること**:
    1.  全機能の統合テストシナリオを作成・実行する。
    2.  エッジケース（空のセッション、大量のノードなど）のテストを実行する。
    3.  発見されたバグの修正を行う。
    4.  コードレビューとリファクタリングを実施する。
-   **テスト方法**:
    1.  全ての基本機能が安定して動作することを確認する。
    2.  次のフェーズ（Merge機能）の準備が整っていることを確認する。

---

## 成功指標

フェーズ1完了時点で以下が達成されていること：

- [ ] 基本的なグラフ表示・操作ができる
- [ ] ノードをクリックしてコンテキスト選択ができる
- [ ] 複数コンテキストを管理できる
- [ ] トークン制限が正しく表示・管理される
- [ ] チャット送信から応答表示まで一連の流れが動作する
- [ ] セッション作成・切り替えができる
- [ ] データがLocalStorageに永続化される
- [ ] エラー時に適切な表示がされる
- [ ] 50ノード程度でもスムーズな操作ができる

この計画に沿って開発を進めることで、フェーズ1のコア機能を段階的かつ確実に構築できます。