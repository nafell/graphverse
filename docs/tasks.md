# MVP開発タスク計画書

このドキュメントは、GraphVerseのMVP（Minimum Viable Product）を構築するための、ステップバイステップのタスク計画を定義します。各タスクは、開発担当LLMが一つずつ実行することを想定して、小さく、テスト可能な単位に分割されています。

---

## ステップ 1: プロジェクトの基盤構築

### タスク 1.1: 依存ライブラリのインストール

-   **目的**: プロジェクトで利用する主要なライブラリをインストールし、開発を開始できる状態にする。
-   **やること**:
    1.  `bun install` コマンドを使い、以下のライブラリをプロジェクトに追加する。
        -   状態管理: `zustand`
        -   グラフ描画: `reactflow`
        -   UIアイコン: `lucide-react`
        -   LLM連携 (Vercel AI SDK): `ai`
        -   LLM連携 (Google Gemini): `@google/generative-ai`
-   **テスト方法**:
    1.  `package.json` ファイルを開き、`dependencies` に上記のライブラリが追加されていることを確認する。
    2.  `bun install` がエラーなく完了することを確認する。

### タスク 1.2: Shadcn/ui の初期化とコンポーネント追加

-   **目的**: UIコンポーネントの基盤となるShadcn/uiをセットアップし、MVPで必要となるコンポーネントを追加する。
-   **やること**:
    1.  `bunx --bun shadcn-ui@latest init` コマンドを実行し、対話形式で設定を行う。
        -   設定値はデフォルトに近い値を選択: `Default`, `Slate`, `src/app/globals.css`, CSS variables, etc.
    2.  `bunx --bun shadcn-ui@latest add` コマンドを使い、以下のコンポーネントを追加する。
        -   `button`
        -   `card`
        -   `textarea`
-   **テスト方法**:
    1.  プロジェクトのルートに `components.json` が作成されていることを確認する。
    2.  `src/lib/utils.ts` が作成されていることを確認する。
    3.  `src/components/ui/` ディレクトリ配下に `button.tsx`, `card.tsx`, `textarea.tsx` が作成されていることを確認する。

---

## ステップ 2: UIの骨格と状態管理の接続

### タスク 2.1: 主要コンポーネントのファイル作成と配置

-   **目的**: アプリケーションの骨格となるコンポーネントの空ファイルを作成し、メインページに配置する。
-   **やること**:
    1.  以下のパスに、コンポーネント名を返す基本的なReactコンポーネントの雛形ファイルを作成する。
        -   `src/components/graph/GraphView.tsx`
        -   `src/components/branch/BranchView.tsx`
    2.  `src/app/page.tsx` を編集し、`GraphView` と `BranchView` をインポートする。
    3.  Tailwind CSSの `flex` を使い、画面を左右に分割して `GraphView` (例: `flex-grow`) と `BranchView` (例: `w-1/3`) を配置する。
-   **テスト方法**:
    1.  ブラウザでアプリを開き、画面が左右に分割され、"GraphView" と "BranchView" のテキストが表示されることを確認する。

### タスク 2.2: データ型とZustandストアの定義

-   **目的**: アプリケーションで扱うデータ構造を定義し、それを管理するグローバルストアを作成する。
-   **やること**:
    1.  `src/types/index.ts` を作成し、`architecture.md` に記載の `ChatNode` と `ChatEdge` の `interface` を定義する。
    2.  `src/store/graphStore.ts` を作成する。
    3.  `zustand` を使い、`nodes` と `edges` の配列、およびそれらを操作するアクション（`addNode`, `addEdge`など）を持つストアを作成する。
    4.  初期状態として、2つのノードと1つのエッジからなるダミーデータを設定する。ノードの `position` は手動で設定する。
-   **テスト方法**:
    1.  指定されたファイルが作成され、コードにTypeScriptエラーがないことを確認する。

### タスク 2.3: GraphViewとZustandストアの接続

-   **目的**: GraphViewコンポーネントでグラフの状態をZustandストアから取得し、描画する。
-   **やること**:
    1.  `GraphView.tsx` を編集する。
    2.  `reactflow` と `graphStore` をインポートする。
    3.  ストアから `nodes` と `edges` を取得する。
    4.  `ReactFlowProvider` と `ReactFlow` コンポーネントを使い、取得した `nodes` と `edges` を画面に描画する。
-   **テスト方法**:
    1.  ブラウザでアプリを開き、左側の領域に2つのノードとそれらを結ぶ線が表示されることを確認する。
    2.  マウスでノードをドラッグしたり、背景をパン・ズームしたりできることを確認する。

---

## ステップ 3: コア機能の実装

### タスク 3.1: カスタムノード(ChatCard)の作成

-   **目的**: グラフ上の各ノードを、チャット情報を表示するカスタムコンポーネントとして表示する。
-   **やること**:
    1.  `src/components/graph/ChatCard.tsx` を作成する。
    2.  `reactflow` の `NodeProps` を型として受け取る。
    3.  `shadcn/ui` の `Card` コンポーネントを使い、ノードのデータ (`data.label`) を表示する。
    4.  `GraphView.tsx` で、作成した `ChatCard` をカスタムノードとして `nodeTypes` に登録し、使用する。
-   **テスト方法**:
    1.  ブラウザ上のグラフのノードが、単なる長方形から、要約テキストが表示されたカード形式に変わっていることを確認する。

### タスク 3.2: チャット入力UIの作成

-   **目的**: ユーザーが新しいチャットメッセージを入力し、送信できるUIを作成する。
-   **やること**:
    1.  `src/components/branch/ChatInput.tsx` を作成する。
    2.  `shadcn/ui` の `Textarea` と `Button` を使い、入力フォームと送信ボタンを配置する。
    3.  `useState` を使ってテキストエリアの入力を管理する。
    4.  `BranchView.tsx` に `ChatInput` コンポーネントをインポートして表示する。
-   **テスト方法**:
    1.  ブラウザでアプリを開き、右側の領域にテキストエリアとボタンが表示されることを確認する。
    2.  テキストエリアに入力ができることを確認する。

### タスク 3.3: APIエンドポイントの雛形作成

-   **目的**: フロントエンドからのリクエストを受け付けるバックエンドの入り口を作成する。
-   **やること**:
    1.  `src/app/api/chat/route.ts` を作成する。
    2.  POSTリクエストを受け取り、リクエストボディをコンソールに出力する。
    3.  固定のJSONオブジェクト (例: `{ message: "Hello from API" }`) をレスポンスとして返す、シンプルな `POST` 関数を実装する。
-   **テスト方法**:
    1.  `curl` やPostmanなどのツールを使い、`http://localhost:3000/api/chat` にPOSTリクエストを送信する。
    2.  ターミナルにリクエストボディが出力され、クライアントに固定のJSONが返却されることを確認する。

### タスク 3.4: フロントエンドからのAPI呼び出しと状態更新

-   **目的**: チャット入力フォームからAPIを呼び出し、その結果（のフリ）をグラフに反映させる。
-   **やること**:
    1.  `ChatInput.tsx` で、送信ボタンクリック時に `fetch` を使って `/api/chat` へPOSTリクエストを送信する処理を追加する。
    2.  Zustandストアの `addNode`, `addEdge` アクションを呼び出す。
    3.  まずユーザーが入力した内容で新しいノード（Userノード）を追加する。
    4.  次に、APIからの応答（今はモック）として、LLMからの返信を表す新しいノード（LLMノード）と、それらをつなぐエッジを追加する。
-   **テスト方法**:
    1.  ブラウザでテキストを入力し送信ボタンを押す。
    2.  グラフ上に新しく2つのノード（ユーザー発言と"Hello from API"）と、それらを結ぶ線が追加されることを確認する。

---

## ステップ 4: LLM連携と本機能の実装

### タスク 4.1: バックエンドでのLLM(Gemini)呼び出し

-   **目的**: APIエンドポイントで、実際にLLM（Gemini 1.5 Flash）を呼び出し、応答を生成する。
-   **やること**:
    1.  `.env.local` ファイルを作成し、`GOOGLE_API_KEY` を設定する。
    2.  `src/app/api/chat/route.ts` を編集する。
    3.  `@google/generative-ai` と `ai` (Vercel AI SDK) ライブラリをインポートする。
    4.  リクエストボディのプロンプトを元に、Vercel AI SDKのGoogle Generative AIプロバイダを使用して`gemini-1.5-flash-latest`モデルを呼び出す。
    5.  Vercel AI SDKの `StreamingTextResponse` を使い、LLMからの応答をストリーミングでクライアントに返す。
-   **テスト方法**:
    1.  `curl` で `/api/chat` に `{ "prompt": "こんにちは" }` のようなリクエストを送信する。
    2.  Geminiからの応答がストリーム形式で返却されることを確認する。

### タスク 4.2: ストリーミング応答のフロントエンド処理

-   **目的**: サーバーからのストリーミング応答をリアルタイムで受け取り、UIに反映させる。
-   **やること**:
    1.  `ChatInput.tsx` のAPI呼び出し部分を修正する。
    2.  Vercel AI SDKの `useChat` フックを利用するようにリファクタリングする。
    3.  `useChat` フックの `messages` を元に、現在のチャット履歴を `BranchView` に表示する。
    4.  `useChat` フックの `handleSubmit` をフォームに接続する。
    5.  応答が完了したタイミング (`onFinish`) で、新しいノードとエッジをZustandストアに追加するロジックを実装する。
-   **テスト方法**:
    1.  ブラウザでチャットを送信する。
    2.  `BranchView` にLLMの応答がリアルタイムで一文字ずつ表示されることを確認する。
    3.  応答完了後、`GraphView` に新しいユーザーノードとLLMノード、そしてエッジが追加されることを確認する。

### タスク 4.3: コンテキスト選択機能の実装

-   **目的**: ユーザーがグラフ上のノードをクリックして、次の対話のコンテキストとして選択できるようにする。
-   **やること**:
    1.  Zustandストアに、選択中のノードIDを管理するための配列 (`selectedNodeIds`) と、それを更新するアクションを追加する。
    2.  `ChatCard.tsx` にクリックイベントを追加し、クリックされたノードのIDをストアの `selectedNodeIds` に追加／削除するアクションを呼び出す。
    3.  選択されているノードのスタイルが変わるように `ChatCard.tsx` のUIを修正する（例: 枠線の色を変える）。
    4.  `useChat`フックの`handleSubmit`に渡すリクエストボディに、ストアから取得した `selectedNodeIds` を含める。
    5.  `/api/chat/route.ts` で `selectedNodeIds` を受け取り、対応するノードのチャット内容をLLM(Gemini)へのプロンプトに含めるように修正する。
-   **テスト方法**:
    1.  グラフ上のノードをクリックすると、カードの見た目が変わることを確認する。
    2.  複数のノードを選択した状態で新しいチャットを送信すると、過去の対話内容を踏まえた応答がLLMから返ってくることを確認する。

---
この計画に沿って開発を進めることで、MVPを段階的かつ確実に構築できます。 